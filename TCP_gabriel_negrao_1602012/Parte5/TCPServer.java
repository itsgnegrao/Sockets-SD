/** @TCPServer: Servidor para conexao TCP com Threads *                Fornece o Socket e conexão entre clientes e processa as mensagens * * Universidade Tecnológica Federal do Paraná - UTFPR-CM * @Autor: Gabriel Negrão Silva * @Data: 29/09/2017 */package Parte5;import static Parte5.TCPServer.Clientes;import java.net.*;import java.io.*;import java.util.ArrayList;public class TCPServer {       public static ArrayList<TaskThread> Clientes;        public static void main (String args[]) {       startServer();    } //main        public static void startServer(){    (new Thread() {        @Override        public void run() {            try{                //lista de todos os clientes                Clientes = new ArrayList<TaskThread>();                                int serverPort = 7896; // porta do servidor                /* cria um socket e mapeia a porta para aguardar conexao */                ServerSocket listenSocket = new ServerSocket(serverPort);                //espera dois clientes para fornecer uma conexão e um gerencia par para gerenciar o canal de dois clientes                while(true) {                    GerenciaPar gerPar = new GerenciaPar();                    System.out.println ("Servidor aguardando conexao Cliente 1...");                    /* aguarda conexoes */                    Socket clientSocket1 = listenSocket.accept();                    System.out.println ("Cliente 1 conectado ... Criando thread ...");                    /* cria um thread para atender a conexao */                    TaskThread c1 = new TaskThread(clientSocket1,"Cliente 1",gerPar);                    Clientes.add(c1);                    gerPar.setC1(c1);                                        System.out.println ("Servidor aguardando conexao Cliente 2...");                    /* aguarda conexoes */                    Socket clientSocket2 = listenSocket.accept();                    System.out.println ("Cliente 2  conectado ... Criando thread ...");                    /* cria um thread para atender a conexao */                    TaskThread c2 = new TaskThread(clientSocket2,"Cliente 2",gerPar);                    Clientes.add(c2);                    gerPar.setC2(c2);                    gerPar.start();                } //while            } catch(IOException e) {                System.out.println("Listen socket:"+e.getMessage());            } //catch        }                void printMsg(String Cliente, String msg){            synchronized(this){//synchronized block                 try{                    System.out.println(Cliente +"disse: "+msg);                    Thread.sleep(400);                 }catch(Exception e){System.out.println(e);}        }    }//end of the method        }    ).start();//Thread   }//metodo        public static void removeClient(TaskThread cli){       Clientes.remove(cli);          }} //class/** * Classe TaskThread: Thread responsavel pela comunicacao * Descricao: Rebebe um socket, cria os objetos de leitura e escrita e aguarda msgs clientes  */class TaskThread extends Thread {    DataInputStream in;    DataOutputStream out;    Socket clientSocket;    String name;    GerenciaPar gerPar;        public TaskThread (Socket aClientSocket, String nomeCli, GerenciaPar gerPar) {        try {            clientSocket = aClientSocket;            in = new DataInputStream( clientSocket.getInputStream());            out =new DataOutputStream( clientSocket.getOutputStream());            this.name=nomeCli;            this.gerPar = gerPar;            this.start();  /* inicializa a thread */        } catch(IOException e) {	    System.out.println("Connection:"+e.getMessage());	} //catch    } //construtor        /* metodo executado ao iniciar a thread - start() */    public void run(){        try {        int i;        String data = "";        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));		while(true){			                 	                     data = in.readUTF();   /* aguarda o recebimento de dados */        	    //System.out.println ("Cliente disse: " + data);                                         synchronized(gerPar){                        gerPar.printMsg(name, data);                    }                                        if(data.equals("SAIR")){                        Clientes.remove(this);                        this.interrupt();                        break;                    }                    else{                       /* for(i=0;i<Clientes.size();i++){                            Clientes.get(i).out.writeUTF(data);                        }*/                    }			}		            } catch (EOFException e){	    System.out.println("EOF: "+e.getMessage());        } catch(IOException e) {	    System.out.println("leitura: "+e.getMessage());        } //catch    } //run} //class