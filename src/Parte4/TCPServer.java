package Parte4;/** * TCPServer: Servidor para conexao TCP com Threads * Descricao: Recebe uma conexao, cria uma thread, recebe uma mensagem e finaliza a conexao */import java.net.*;import java.io.*;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.logging.Level;import java.util.logging.Logger;import java.io.DataInputStream;public class TCPServer {       public static ArrayList<TaskThread> Clientes;        public static void main (String args[]) {       startServer();    } //main        public static void startServer(){    (new Thread() {        @Override        public void run() {            try{                Clientes = new ArrayList<TaskThread>();                int serverPort = 7896; // porta do servidor                /* cria um socket e mapeia a porta para aguardar conexao */                ServerSocket listenSocket = new ServerSocket(serverPort);                while(true) {                    System.out.println ("Servidor aguardando conexao ...");                    /* aguarda conexoes */                    Socket clientSocket = listenSocket.accept();                    System.out.println ("Cliente conectado ... Criando thread ...");                    /* cria um thread para atender a conexao */                    TaskThread c = new TaskThread(clientSocket);                    Clientes.add(c);                } //while            } catch(IOException e) {                System.out.println("Listen socket:"+e.getMessage());            } //catch                }        }    ).start();//Thread   }//metodo       public static void removeClient(TaskThread cli){       Clientes.remove(cli);          }} //class/** * Classe TaskThread: Thread responsavel pela comunicacao * Descricao: Rebebe um socket, cria os objetos de leitura e escrita e aguarda msgs clientes  */class TaskThread extends Thread {    private static DataInputStream in;    private static DataOutputStream out;    private static FileInputStream outToClient;    private static Socket clientSocket;    private static Thread servidorEnviaFILE;        public TaskThread (Socket aClientSocket) {        try {            clientSocket = aClientSocket;            in = new DataInputStream( clientSocket.getInputStream());            out =new DataOutputStream( clientSocket.getOutputStream());            this.start();  /* inicializa a thread */        } catch(IOException e) {	    System.out.println("Connection:"+e.getMessage());	} //catch    } //construtor        /* metodo executado ao iniciar a thread - start() */    public void run(){        try {        int i;        File f = null;        String data = "";		while(true){			                 	                     data = in.readUTF();   /* aguarda o recebimento de dados */                     String parse = data.replaceAll("\\[.*\\]\\: ", "");        	    System.out.println (data);                                                             /*TIME Retorna a hora do sistema como uma String UTF no formato HH:MM:SS + PM/AM*/                    if(parse.equals("TIME")){                        Date dateToFormat = new Date();                        SimpleDateFormat dateFormatExpression = new SimpleDateFormat("hh:mm:ss a"+"\n");                        String formattedDate = dateFormatExpression.format(dateToFormat);                        out.writeUTF(formattedDate);                        out.flush();                    }                                        /*Retorna os arquivos da pasta pré definida*/                    else if(parse.equals("FILES")){                        f = new File("/home/itsgnegrao/Documentos/Shared");                        File[] list = f.listFiles();                                                                   /*for (File file : list) {                            data = data.concat("Size: "+Long.toString(file.length())+"____________"+file.getName()+"\n");                        }*/                        out.writeUTF("QTD-PATH");                        out.flush();                        out.writeInt(list.length);                        out.flush();                                                for (File file : list) {                            TCPServidorEnviaQTD_FILE(file, Integer.toString(list.length));                            System.out.println(out.size());                        }                                                                    }                    /*REtorna o arquivo solicitado*/                    else if(parse.contains("DOWN ")){                        parse = parse.replace("DOWN ", "");                        parse = parse.replace("\n","").replace("\r", "");                        System.out.println("/home/itsgnegrao/Documentos/Shared"+parse);                        out.writeUTF("DOWN");                        out.flush();                        outToClient = new FileInputStream(parse);                        byte[] buffer = new byte[4096];                        while (outToClient.read(buffer) > 0) {                                out.write(buffer);                        }                        outToClient.close();                    }                    /*DATE Retorna a data do sistema como uma String UTF no formato DD/MM/AAAA*/                    else if(parse.equals("DATA")){                        Date dateToFormat = new Date();                        SimpleDateFormat dateFormatExpression = new SimpleDateFormat("dd/MM/yyyy"+"\n");                        String formattedDate = dateFormatExpression.format(dateToFormat);                        out.writeUTF(formattedDate);                        out.flush();                    }                                        /*EXIT Finaliza a conexão*/                    else if(parse.equals("EXIT")){                        TCPServer.removeClient(this);                        this.interrupt();                        out.writeUTF("EXIT");                        out.flush();                    }                                        else{                        out.writeUTF(data);                        out.flush();                    }                }                } catch (EOFException e){	    System.out.println("EOF: "+e.getMessage());        } catch(IOException e) {	    System.out.println("leitura: "+e.getMessage());        } //catch	    } //run            public static void TCPServidorEnviaQTD_FILE(File file, String total){            long tamanhoTot =  file.length();            String nomeArq = file.getName();                        File f = null;            FileInputStream fis = null;                            //try{                    System.out.println("CRIOOOOU");                    System.out.println(nomeArq);                    System.out.println(tamanhoTot);                try {                    out.writeUTF("FILES");                    out.flush();                    out.writeUTF(nomeArq);                    out.flush();                    out.writeLong(tamanhoTot);                    out.flush();                } catch (IOException ex) {                    Logger.getLogger(TaskThread.class.getName()).log(Level.SEVERE, null, ex);                }                                                            /*byte[] mybytearray = new byte[(int) file.length()];                    fis = new FileInputStream(file);                    BufferedInputStream bis = new BufferedInputStream(fis);                    bis.read(mybytearray, 0, mybytearray.length);                    outToClient.write(mybytearray, 0, mybytearray.length);                    outToClient.flush();                                        /*} catch (UnknownHostException e){                    System.out.println("Socket:-TCPServidorEnviaFILE-"+e.getMessage());                } catch (EOFException e){                    System.out.println("EOF:-TCPServidorEnviaFILE-"+e.getMessage());                } catch (IOException e){                    System.out.println("leitura-TCPServidorEnviaFILE-:"+e.getMessage());                } //catch*/   }//metodo        } //class